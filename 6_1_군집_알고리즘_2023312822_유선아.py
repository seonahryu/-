# -*- coding: utf-8 -*-
"""6-1 군집 알고리즘_2023312822 유선아

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14P90s-NYkBHso53G6hB68-DzjBY5bQXK

# 군집 알고리즘

- 타킷을 모르는 비지도 학습
- 타깃이 없을 때 사용하는 머신러닝 알고리즘, 사람이 가르쳐 주지 않아도 데이터에 있는 무언가를 학습하는 것

<table align="left">
  <td>
    <a target="_blank" href="https://colab.research.google.com/github/rickiepark/hg-mldl/blob/master/6-1.ipynb"><img src="https://www.tensorflow.org/images/colab_logo_32px.png" />구글 코랩에서 실행하기</a>
  </td>
</table>

## 과일 사진 데이터 준비하기
"""

!wget https://bit.ly/fruits_300_data -O fruits_300.npy
# 사과, 바나나, 파인애플을 담고 있는 흑백사진 데이터 다운로드
# ! 문자로 시작하면 리눅스 셀 명령
# wget 명령은 원격 주소에서 데이터를 다운로드 및 저장
# 0 옵션에서 저장할 파일 이름 지정
# .npy는 넘파이 배열의 기본 저장 포맷

import numpy as np
import matplotlib.pyplot as plt
# numpy 와 matplot import

fruits = np.load('fruits_300.npy')
# fruits_300.npy 파일에 있는 모든 데이터를 fruits에 할당

print(fruits.shape)
# fruits의 형태 출력
# 300개의 sample (이미지)
# 이미지의 크기 100*100 (100 이미지 높이, 100 이미지 너비)
# 각 픽셀은 넘파이 배열의 원소 하나에 대응 -> 배열의 크기 100*100

print(fruits[0, 0, :])
# 첫 번째 이미지의 첫 번째 행 출력
# 흑백사진을 담고 있는 넘파이 배열(0~255 정숫값)

plt.imshow(fruits[0], cmap='gray')
plt.show()
# imshow() 함수를 통해 넘파이 배열로 저장된 이미지 출력
# 첫 번째 샘플이미지(fruits[0]) 출력
# 흑백 이미지이으로 cmap 매개변수를 gray로 지정
# 0에 가까운 배열 값일수록 검게 나타나고 높은 값은 밝게 표시됨
# 255에 가까운 값에 집중 (배경말고 사과의 shape 집중)(픽셀값이 높으면 출력값도 커지기 때문에 의미 부여가 좋음)
# 중간에 큰 값 나타나는 부분이 사과 꼭지를 의미하는 것이었겠구나!

plt.imshow(fruits[0], cmap='gray_r')
plt.show()
# cmap 매개변수를 gray_r로 지정하여 사람 눈에 보기 좋게 반전된 이미지 출력
# 밝은 부분 0에 가깝고, 어두운 부분 255에 가까운 값

fig, axs = plt.subplots(1, 2)
# subplots을 활용하여 2개 이상의 그래프를 하나의 figure에 출력
# subplots을 (1,2)을 통해서 1행 2열의 subplots이 나오게 함

axs[0].imshow(fruits[100], cmap='gray_r')
axs[1].imshow(fruits[200], cmap='gray_r')
plt.show()
# 300장 중 100장 사과, 100장 바나나, 100장 파인애플이라는 사전정보를 안 상태로 인덱스에 맞춰서 파인애플과 바나나 출력

"""## 픽셀 값 분석하기"""

apple = fruits[0:100].reshape(-1, 100*100)
pineapple = fruits[100:200].reshape(-1, 100*100)
banana = fruits[200:300].reshape(-1, 100*100)
# 인덱스 슬라이싱으로 각 과일을 분류
# 각 과일의 픽셀을 분석하기 위해, reshape() 길이가 10000인 1차원 배열로 바꾸기 (100X100 이미지는 2차원)
# reshape()의 '-1'이 의미하는 바는, 변경된 배열의 '-1' 위치의 차원은 "원래 배열의 길이와 남은 차원으로 부터 추정"
# 행이나 열의 특정 차원을 기준으로 재배열하고 싶은 행이나 열의 개수가 있으면 나머지 차원의 개수는 '-1'로 해두면 알아서 자동으로 재배열
# 첫번째 차원이 샘플 개수이므로 10000 길이의 1차원 배열 이미지가 100개

print(apple.shape)
# 사과의 형태 출력

print(apple.mean(axis=1))
# axis=1 두 번째 축인 열을 따라 계산
# 샘플별로 평균값 계산

plt.hist(np.mean(apple, axis=1), alpha=0.8)
plt.hist(np.mean(pineapple, axis=1), alpha=0.8)
plt.hist(np.mean(banana, axis=1), alpha=0.8)
plt.legend(['apple', 'pineapple', 'banana'])
# 범례를 과일에 맞게 applr, pineapple, banana로 설정

plt.show()
# alpha를 1보다 작게 해서 투명도 조절
# 히스토그램은 누적 분포 시각화에 많이 씀, 각 과일의 평균값이 어떻게 분포되어 있는지 출력
# 비지도학습에서는 데이터가 겹치지 않아야 제대로된 분류를 할 수 있음
# 사과와 파인애플이 많이 겹쳐있어서 픽셀값만으로는 구분하기 어려움 -> 샘플별로(행별) 분류하지 말고 다른 방법!

fig, axs = plt.subplots(1, 3, figsize=(20, 5))
# subplots을 (1,3)을 통해서 1행과 3열의 subplots이 나오게 함
# figure size를 20, 5로 설정

axs[0].bar(range(10000), np.mean(apple, axis=0))
axs[1].bar(range(10000), np.mean(pineapple, axis=0))
axs[2].bar(range(10000), np.mean(banana, axis=0))
plt.show()
# axis=0 행 따라서 픽셀 위치별로 평균값 구해
# 과일마다 해서 3개의 그래프
# 과일마다 값이 높은 구간이 다름
# 사과는 사진 아래쪽으로 갈수록 값이 높아짐, 파인애플은 전체적으로 고르고 높음, 바나나는 중앙의 픽셀값이 높음

apple_mean = np.mean(apple, axis=0).reshape(100, 100)
pineapple_mean = np.mean(pineapple, axis=0).reshape(100, 100)
banana_mean = np.mean(banana, axis=0).reshape(100, 100)
# 10000개를 평균값으로 바꾼 것을 2차원으로 reshape (100, 100) 이미지처럼 보겠다

fig, axs = plt.subplots(1, 3, figsize=(20, 5))
# subplots을 (1, 3)을 통해서 1행과 3열의 subplots이 나오게 함
# figuresize를 20, 5로 설정

axs[0].imshow(apple_mean, cmap='gray_r')
axs[1].imshow(pineapple_mean, cmap='gray_r')
axs[2].imshow(banana_mean, cmap='gray_r')
plt.show()
# 픽셀을 평균낸 각 과일의 이미지 출력
# 대표 이미지와 가까운 사진을 골라낸다면 과일을 구분할 수 있지 않을까?

"""## 평균값과 가까운 사진 고르기"""

abs_diff = np.abs(fruits - apple_mean)
abs_mean = np.mean(abs_diff, axis=(1,2))
# abs() 함수에 배열을 입력하면, 모든 원소의 절대값을 계산하여 입력과 동일한 크기의 배열 반환
# fruits 배열에 있는 모든 샘플에서 apple_mean을 뺀 절대값 계산
# axis(1,2)을 통해 1, 2축을 따라서 배열의 산술 평균 계산

print(abs_mean.shape)
# abs_mean의 형태 출력
# abs_mean은 각 샘플의 오차 평균이므로 크기가 (300,)인 1차원 배열

apple_index = np.argsort(abs_mean)[:100]
# np.argsort를 통해 차이가 가장 작은 순서대로 100개의 데이터 선정

fig, axs = plt.subplots(10, 10, figsize=(10,10))
for i in range(10):
    for j in range(10):
        axs[i, j].imshow(fruits[apple_index[i*10 + j]], cmap='gray_r')
        axs[i, j].axis('off')
# 2중 for 문을 통해 10개의 행과 열에 이미지 출력
# axis('off')을 사용해서 좌표축 생략

plt.show()
# task = 군집 = 비슷한 샘플끼리 그룹을 모으는 작업
# 군집은 대표적인 비지도 학습 작업 중 하나
# result = 클러스터(군집 알고리즘에서 만든 그룹)

"""## 확인문제"""

abs_diff = np.abs(fruits - banana_mean)
abs_mean = np.mean(abs_diff, axis=(1,2))
# fruits 배열에 있는 모든 샘플에서 banana_mean을 뺀 절대값의 평균 계산
# axis(1,2)을 통해 1, 2축을 따라서 배열의 산술 평균 계산

banana_index = np.argsort(abs_mean)[:100]
# np.argsort를 통해 차이가 가장 작은 순서대로 100개의 데이터 선정

fig, axs = plt.subplots(10, 10, figsize=(10,10))
for i in range(10):
    for j in range(10):
        axs[i, j].imshow(fruits[banana_index[i*10 + j]], cmap='gray_r')
        axs[i, j].axis('off')
# 2중 for 문을 통해 10개의 행과 열에 이미지 출력
# axis('off')를 사용해서 좌표축 생략

plt.show()
#사과 이미지가 있는 것으로 보아 완벽한 분류가 이루어지지 않았음을 알 수 있음
#군집에 대한 사전 정보를 갖고 있고, 이미지 데이터이므로 픽셀을 써야겠다는 것을 알고 있어서 이렇게 할 수 있었음
# 사전정보, class 정보 없으면 kmeans 비지도 학습을 함