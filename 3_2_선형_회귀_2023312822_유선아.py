# -*- coding: utf-8 -*-
"""3-2 선형 회귀_2023312822 유선아

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JOx0JcOqaTgIVm5NEpLx4JASk-dqWMM1

# 선형 회귀

<table align="left">
  <td>
    <a target="_blank" href="https://colab.research.google.com/github/rickiepark/hg-mldl/blob/master/3-2.ipynb"><img src="https://www.tensorflow.org/images/colab_logo_32px.png" />구글 코랩에서 실행하기</a>
  </td>
</table>

## k-최근접 이웃의 한계
"""

import numpy as np

perch_length = np.array(
    [8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0,
     21.0, 21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5,
     22.5, 22.7, 23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5,
     27.3, 27.5, 27.5, 27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0,
     36.5, 36.0, 37.0, 37.0, 39.0, 39.0, 39.0, 40.0, 40.0, 40.0,
     40.0, 42.0, 43.0, 43.0, 43.5, 44.0]
     )
# 넘파이 배열의 농어 길이

perch_weight = np.array(
    [5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0,
     110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0,
     130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0,
     197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0,
     514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0,
     820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0,
     1000.0, 1000.0]
     )
# 넘파이 배열의 농어 무게

from sklearn.model_selection import train_test_split

train_input, test_input, train_target, test_target = train_test_split(
    perch_length, perch_weight, random_state=42)
# 훈련 세트와 테스트 세트로 나눔

train_input = train_input.reshape(-1, 1)
test_input = test_input.reshape(-1, 1)
# 훈련 세트와 테스트 세트를 2차원 배열로 바꿈

from sklearn.neighbors import KNeighborsRegressor
knr = KNeighborsRegressor(n_neighbors=3)
# 객체 선언할 때 k 설정할 수 있음

knr.fit(train_input, train_target)
# k-최근접 이웃 회귀 모델 훈련

print(knr.predict([[50]]))
# 길이가 50cm인 농어 무게 예측 // 실제 무게는 더 무거움
# k-최근접 이웃 회귀를 사용해서 농어의 무게를 예측할 때, 훈련 세트 범위 밖의 샘플은 예측할 수 X
# 샘플(unseen data)이 아무리 멀리 떨어져 있어도 무조건 가까운 샘플의 타킷을 평균하여 예측하기 때문

import matplotlib.pyplot as plt

distances, indexes = knr.kneighbors([[50]])
# 50cm 농어의 이웃을 구함

plt.scatter(train_input, train_target)
# 훈련 세트의 산점도 그림

plt.scatter(train_input[indexes], train_target[indexes], marker='D')
# 훈련 세트 중에서 이웃 샘플만 다이아몬드로 다시 그림

plt.scatter(50, 1033, marker='^')
# 50cm 농어 데이터를 세모로 나타냄

plt.xlabel('length')
plt.ylabel('weight')
plt.show()

print(np.mean(train_target[indexes]))
# 이웃 샘플의 타깃의 평균

print(knr.predict([[100]]))
# 길이가 100cm인 농어의 무게 예측 값 동일함
# 농어가 아무리 커져도 무게가 더 늘어나지X
# 50cm 농어에서 가장 가까운 것은 45cm 근방이기 때문에 k-최근접 이웃 알고리즘은 이 샘플들의 무게를 평균내어 예측하기 때문

distances, indexes = knr.kneighbors([[100]])
# 100cm 농어의 이웃을 구함

plt.scatter(train_input, train_target)
# 훈련 세트의 산점도 그림

plt.scatter(train_input[indexes], train_target[indexes], marker='D')
# 훈련 세트 중에서 이웃 샘플 다이아몬드 모양으로 그림

plt.scatter(100, 1033, marker='^')
# 100cm 농어 데이터를 세모로 그림

plt.xlabel('length')
plt.ylabel('weight')
plt.show()

"""## 선형 회귀"""

from sklearn.linear_model import LinearRegression

lr = LinearRegression()
lr.fit(train_input, train_target)
# 선형 회귀 모델 훈련

print(lr.predict([[50]]))
# 50cm 농어에 대한 예측

print(lr.coef_, lr.intercept_)
# 회귀식의 coef_(a, 기울기)와 intercept_(b, 절편) 출력
# coef_, intercept_를 머신러닝 알고리즘이 찾은 값이라는 의미로 모델 파라미터 라고 함

plt.scatter(train_input, train_target)
# 훈련 세트의 산점도 그림

plt.plot([15, 50], [15*lr.coef_+lr.intercept_, 50*lr.coef_+lr.intercept_])
# 15에서 50까지 1차 방정식 그래프 그림

plt.scatter(50, 1241.8, marker='^')
# 50cm 농어 데이터를 주황색 세모로 나타냄

plt.xlabel('length')
plt.ylabel('weight')
plt.show()

print(lr.score(train_input, train_target))
# 훈련 세트 score

print(lr.score(test_input, test_target))
# 테스트 세트 score

# 훈련 세트(0.93)>테스트 세트(0.82)

"""## 다항 회귀 (다항식을 사용한 선형회귀)

최적의 곡선을 찾아보자.
2차 방정식의 그래프를 그리기 위해 길이의 제곱항을 훈련세트에 추가.
"""

train_poly = np.column_stack((train_input ** 2, train_input))
# train_input ** 2 -> 넘파이 브로드캐스팅 적용(data의 차원 맞춰주는 기능)
# train_input을 제곱한 것과 train _input 두 배열을 나란히 붙힘

test_poly = np.column_stack((test_input ** 2, test_input))

print(train_poly.shape, test_poly.shape)
# 행=data개수, 열=2

lr = LinearRegression()
lr.fit(train_poly, train_target)
# 모델 훈련 (train_poly=x, train_target=y)
# 2차 방정식 그래프를 찾기 위해 훈련 세트에 제곱 항을 추가, 타겟 값은 그대로 사용

print(lr.predict([[50**2, 50]]))
# 길이가 50cm인 농어의 무게 예측

print(lr.coef_, lr.intercept_)
# 계수, 절편 / 다항 회귀식의 coef_와 intercept_ 출력
# 무게 = 1.01x길이**2 - 21.6x길이 + 116.05

point = np.arange(15, 50)
# 구간별 직선을 그리기 위해 15에서 49까지 정수 배열을 만듭니다

plt.scatter(train_input, train_target)
# 훈련 세트의 산점도를 그립니다

plt.plot(point, 1.01*point**2 - 21.6*point + 116.05)
# 15에서 49까지 2차 방정식 그래프를 그립니다

plt.scatter([50], [1574], marker='^')
# 50cm 농어 데이터

plt.xlabel('length')
plt.ylabel('weight')
plt.show()

print(lr.score(train_poly, train_target))
# 훈련 세트 score(R^2) 출력

print(lr.score(test_poly, test_target))
# 테스트 세트 score(R^2) 출력
# 테스트 세트 점수가 약간 더 커서 underfitting 발생
# 선형회귀(훈련 세트(0.93), 테스트 세트(0.82))보다 높은 정확도